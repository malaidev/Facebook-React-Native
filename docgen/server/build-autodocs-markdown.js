/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
"use strict";

var fs = require("fs");
var glob = require("glob");
var Promise = require("bluebird");
var mkdirp = require("mkdirp");
var slugify = require("../core/slugify");
var jsdom = require("jsdom");

const { JSDOM } = jsdom;

var queue = Promise.resolve();

function bodyContentFromDOM(dom) {
  const el = dom.window.document.querySelector("#componentContent");
  if (el) {
    return el.innerHTML;
  } else {
    return null;
  }
}

function componentNameFromDOM(dom) {
  const el = dom.window.document.querySelector("title");
  if (el) {
    return el.innerHTML;
  } else {
    return "Component";
  }
}

function componentCategoryFromDOM(dom) {
  const el = dom.window.document.querySelector('meta[property="rn:category"]');
  if (el) {
    return el.content;
  } else {
    return "Components";
  }
}

/**
 * Generates a markdown formatted file, including frontmatter.
 * 
 * @param {*} dom 
 */
function generateMarkdownFromDOM(dom) {
  const body = bodyContentFromDOM(dom);
  if (!body) {
    return;
  }
  const componentName = componentNameFromDOM(dom);
  const slug = slugify(componentName);
  let category = "Components";
  const componentCategory = componentCategoryFromDOM(dom);
  if (componentCategory) {
    category = componentCategory;
  }
  const metadata = { id: slug, category: category };
  const res = [
    "---",
    "id: " + slug,
    "title: " + componentName,
    "category: " + category,
    "permalink: docs/" + slug + ".html",
    "---",
    body
  ]
    .filter(function(line) {
      return line;
    })
    .join("\n");
  const targetFile = "../docs/autogen_" + componentName + ".md";
  mkdirp.sync(targetFile.replace(new RegExp("/[^/]*$"), ""));
  console.log("Writing " + targetFile);
  fs.writeFileSync(targetFile, res);
  return metadata;
}

function generateMetatadaFile(categories) {
  const categoriesMetadataFile = "build/sidebar-metadata.json";
  fs.writeFileSync(categoriesMetadataFile, JSON.stringify(categories));
}

/**
 * Updates sidebar.json with the autogenerated API docs, without overwriting existing sections/categories.
 * 
 * @param {*} categories 
 */
function updateSidebarSync() {
  const categoriesMetadataFile = "build/sidebar-metadata.json";
  const categories = JSON.parse(fs.readFileSync(categoriesMetadataFile));
  const sidebarFile = "../website/sidebars.json";
  let sidebarContent = { SIDEBAR_AUTODOCS_SECTION: {} };
  if (fs.existsSync(sidebarFile)) {
    sidebarContent = JSON.parse(fs.readFileSync(sidebarFile));
  }

  let sortedCategories = {};
  for (var category in categories) {
    const sortedCategory = categories[category].sort();
    sortedCategories[category] = sortedCategory;
  }

  const newSidebarContent = Object.assign({}, sidebarContent, {
    API: sortedCategories
  });

  fs.writeFileSync(sidebarFile, JSON.stringify(newSidebarContent));
  console.log(`Updated ${sidebarFile}`);
}

// Generate HTML for each non-source code JS file
glob("build/**/*.html", function(er, files) {
  let categories = {};
  files.forEach(function(file) {
    queue = queue
      .then(function() {
        return JSDOM.fromFile(file);
      })
      .then(function(dom) {
        const metadata = generateMarkdownFromDOM(dom);
        if (categories[metadata.category]) {
          categories[metadata.category].push(metadata.id);
        } else {
          categories[metadata.category] = [metadata.id];
        }
      });
  });

  queue = queue.then(function() {
    console.log("Generated Markdown files from HTML");
    generateMetatadaFile(categories);
  })
  .catch(function(e) {
    console.error(e);
    process.exit(1);
  });
});
