/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
"use strict";

var fs = require("fs");
var glob = require("glob");
var Promise = require("bluebird");
var mkdirp = require("mkdirp");
var slugify = require("../core/slugify");
var jsdom = require("jsdom");

const { JSDOM } = jsdom;

var queue = Promise.resolve();

function bodyContentFromDOM(dom) {
  const el = dom.window.document.querySelector("#componentContent");
  if (el) {
    return el.innerHTML;
  } else {
    return null;
  }
}

function componentNameFromDOM(dom) {
  const el = dom.window.document.querySelector("title");
  if (el) {
    return el.innerHTML;
  } else {
    return "Component";
  }
}

function componentCategoryFromDOM(dom) {
  const el = dom.window.document.querySelector('meta[property="rn:category"]');
  if (el) {
    return el.content;
  } else {
    return "Components";
  }
}

/**
 * Updates sidebar.json with the autogenerated API docs, without overwriting existing sections/categories.
 * 
 * @param {*} categories 
 */
function updateSidebarSync(categories) {
  const sidebarFile = "../website/sidebars.json";
  let sidebarContent = { SIDEBAR_AUTODOCS_SECTION: {} };
  if (fs.existsSync(sidebarFile)) {
    sidebarContent = JSON.parse(fs.readFileSync(sidebarFile));
  }

  let sortedCategories = {};
  for (var category in categories) {
    const sortedCategory = categories[category].sort();
    sortedCategories[category] = sortedCategory;
    // TODO: replace with spread once babelized?
  }

  const newSidebarContent = Object.assign({}, sidebarContent, {
    API: sortedCategories
  });

  fs.writeFileSync(sidebarFile, JSON.stringify(newSidebarContent));
}

// Generate HTML for each non-source code JS file
glob("build/**/*.html", function(er, files) {
  let categories = {};
  files.forEach(function(file) {
    queue = queue
      .then(function() {
        return JSDOM.fromFile(file);
      })
      .then(function(dom) {
        const body = bodyContentFromDOM(dom);
        if (!body) {
          console.log("Skipping " + file);
          return;
        }
        const componentName = componentNameFromDOM(dom);
        const slug = slugify(componentName);
        let category = "Components";
        const componentCategory = componentCategoryFromDOM(dom);
        if (componentCategory) {
          category = componentCategory;
        }
        const metadata = { id: slug, category: category };
        const res = [
          "---",
          "id: " + slug,
          "title: " + componentName,
          "sidebar: api",
          "category: " + category,
          "permalink: docs/" + slug + ".html",
          "---",
          body
        ]
          .filter(function(line) {
            return line;
          })
          .join("\n");
        const targetFile = "../docs/autogen_" + componentName + ".md";
        mkdirp.sync(targetFile.replace(new RegExp("/[^/]*$"), ""));
        console.log("Writing " + targetFile);
        fs.writeFileSync(targetFile, res);
        if (categories[category]) {
          categories[category].push(slug);
        } else {
          categories[category] = [slug];
        }
      })
      .catch(function(error) {
        console.error("Skipping " + targetFile + ": " + error);
      });
  });

  queue = queue
    .then(function() {
      console.log("Generated Markdown files from HTML");
      updateSidebarSync(categories);
    })
    .catch(function(e) {
      console.error(e);
      process.exit(1);
    });
});

// TODO: Generate a sidebar. Looks like this:
/*
{
  "docs": {
    "The Basics": ["doc1"],
    "Guides": ["doc2"],
    "Components": ["doc3"],
    "APIs": ["doc3"]
  },
  "docs-other": {
    "First Category": ["doc4", "doc5"]
  }
}
I'm guessing for API/Components we can just do it alphabetically.
For everything else, we can get an initial order from the frontmatter, and bake it into the sidebar.
Then we can make sure that the build script only updates the API and Components keys, leaving Guides/The Basics untouched.
*/
