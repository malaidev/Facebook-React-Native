---
id: version-0.50-timers
title: timers
original_id: timers
---
<a id="content"></a><h1><a class="anchor" name="timers"></a>Timers <a class="hash-link" href="docs/timers.html#timers">#</a></h1><div><p>Timers are an important part of an application and React Native implements the <a href="https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers" target="_blank">browser timers</a>.</p><h2><a class="anchor" name="timers"></a>Timers <a class="hash-link" href="docs/timers.html#timers">#</a></h2><ul><li>setTimeout, clearTimeout</li><li>setInterval, clearInterval</li><li>setImmediate, clearImmediate</li><li>requestAnimationFrame, cancelAnimationFrame</li></ul><p><code>requestAnimationFrame(fn)</code> is not the same as <code>setTimeout(fn, 0)</code> - the former will fire after all the frame has flushed, whereas the latter will fire as quickly as possible (over 1000x per second on a iPhone 5S).</p><p><code>setImmediate</code> is executed at the end of the current JavaScript execution block, right before sending the batched response back to native. Note that if you call <code>setImmediate</code> within a <code>setImmediate</code> callback, it will be executed right away, it won't yield back to native in between.</p><p>The <code>Promise</code> implementation uses <code>setImmediate</code> as its asynchronicity primitive.</p><h2><a class="anchor" name="interactionmanager"></a>InteractionManager <a class="hash-link" href="docs/timers.html#interactionmanager">#</a></h2><p>One reason why well-built native apps feel so smooth is by avoiding expensive operations during interactions and animations. In React Native, we currently have a limitation that there is only a single JS execution thread, but you can use <code>InteractionManager</code> to make sure long-running work is scheduled to start after any interactions/animations have completed.</p><p>Applications can schedule tasks to run after interactions with the following:</p><div class="prism language-javascript">InteractionManager<span class="token punctuation">.</span><span class="token function">runAfterInteractions</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true"> // ...long-running synchronous task...
</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div><p>Compare this to other scheduling alternatives:</p><ul><li>requestAnimationFrame(): for code that animates a view over time.</li><li>setImmediate/setTimeout/setInterval(): run code later, note this may delay animations.</li><li>runAfterInteractions(): run code later, without delaying active animations.</li></ul><p>The touch handling system considers one or more active touches to be an 'interaction' and will delay <code>runAfterInteractions()</code> callbacks until all touches have ended or been cancelled.</p><p>InteractionManager also allows applications to register animations by creating an interaction 'handle' on animation start, and clearing it upon completion:</p><div class="prism language-javascript"><span class="token keyword">var</span> handle <span class="token operator">=</span> InteractionManager<span class="token punctuation">.</span><span class="token function">createInteractionHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// run animation... (`runAfterInteractions` tasks are queued)
</span><span class="token comment" spellcheck="true">// later, on animation completion:
</span>InteractionManager<span class="token punctuation">.</span><span class="token function">clearInteractionHandle</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// queued tasks run if all handles were cleared</span></div><h2><a class="anchor" name="timermixin"></a>TimerMixin <a class="hash-link" href="docs/timers.html#timermixin">#</a></h2><p>We found out that the primary cause of fatals in apps created with React Native was due to timers firing after a component was unmounted. To solve this recurring issue, we introduced <code>TimerMixin</code>. If you include <code>TimerMixin</code>, then you can replace your calls to <code>setTimeout(fn, 500)</code> with <code>this.setTimeout(fn, 500)</code> (just prepend <code>this.</code>) and everything will be properly cleaned up for you when the component unmounts.</p><p>This library does not ship with React Native - in order to use it on your project, you will need to install it with <code>npm i react-timer-mixin --save</code> from your project directory.</p><div class="prism language-javascript"><span class="token keyword">import</span> TimerMixin <span class="token keyword">from</span> <span class="token string">'react-timer-mixin'</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> Component <span class="token operator">=</span> <span class="token function">createReactClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  mixins<span class="token punctuation">:</span> <span class="token punctuation">[</span>TimerMixin<span class="token punctuation">]</span><span class="token punctuation">,</span>
  componentDidMount<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I do not leak!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token number">500</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div><p>This will eliminate a lot of hard work tracking down bugs, such as crashes caused by timeouts firing after a component has been unmounted.</p><p>Keep in mind that if you use ES6 classes for your React components <a href="https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#mixins" target="_blank">there is no built-in API for mixins</a>. To use <code>TimerMixin</code> with ES6 classes, we recommend <a href="https://github.com/brigand/react-mixin" target="_blank">react-mixin</a>.</p></div><div class="docs-prevnext"><a class="docs-prev btn" href="docs/improvingux.html#content">← Previous</a><a class="docs-next btn" href="docs/debugging.html#content">Continue Reading →</a></div><p class="edit-page-block"><a target="_blank" href="https://github.com/facebook/react-native/blob/master/docs/Timers.md">Improve this page</a> by sending a pull request!</p>